// =============================================================================
// ORBIS DSL BUILD SYSTEM - Documentation Generation
// =============================================================================
//
// This module generates human-readable Markdown documentation from the
// component definitions. The documentation serves multiple purposes:
//
// 1. **Developer Reference**: Complete list of all components, attributes,
//    and events available in the Orbis DSL.
//
// 2. **IDE Support**: Can be used by language servers for hover info and
//    completion tooltips.
//
// 3. **Deprecation Notices**: Clearly marks deprecated attributes/events
//    with migration guidance.
//
// 4. **Type Information**: Shows expected types and allowed values for
//    each attribute.
//
// The generated documentation is written to `COMPONENTS_REFERENCE.md` in
// the crate root directory.
//
// =============================================================================
//
// NOTE: This file is designed to be used with `include!` in build.rs.
// All dependencies (types, functions) must be brought into scope by the
// including file BEFORE this file is included.
//
// Required imports in build.rs before include:
// - std::fs::File
// - std::io::Write
// - ComponentDef, AttributeDef, EventDef from data_structures.rs
//
// =============================================================================

// =============================================================================
// MAIN DOCUMENTATION GENERATOR
// =============================================================================

/// Generates complete Markdown documentation for all components.
///
/// Creates a structured reference document with:
/// - Table of contents with links to each component
/// - Per-component sections with attributes and events
/// - Type information and allowed values
/// - Deprecation warnings with migration guidance
///
/// # Arguments
/// * `components` - The complete list of component definitions
///
/// # Output
/// Writes to `COMPONENTS_REFERENCE.md` in the crate root.
///
/// # Example Output
/// ```markdown
/// # Orbis DSL Component Reference
///
/// ## Table of Contents
/// - [Button](#button)
/// - [Container](#container)
/// ...
///
/// ## Button
/// A clickable button element.
///
/// ### Attributes
/// | Attribute | Type | Allowed Values | Deprecated |
/// |-----------|------|----------------|------------|
/// | label | string | - | No |
/// | variant | string | default, destructive, outline | No |
/// ...
/// ```
pub fn generate_component_documentation(components: &[ComponentDef]) {
    let doc_path = std::path::Path::new("COMPONENTS_REFERENCE.md");
    let mut f = File::create(doc_path).expect("Failed to create documentation file");

    // =========================================================================
    // Document header
    // =========================================================================
    writeln!(
        f,
        "# Orbis DSL Component Reference

> **Auto-generated documentation** — This file is automatically generated by the
> Orbis build system. Do not edit manually; changes will be overwritten.
> 
> To update, modify component definitions in `build/components.rs`.

This document provides a complete reference for all components, attributes,
and events available in the Orbis DSL. Use this as a quick reference when
writing page templates.

---

"
    )
    .unwrap();

    // =========================================================================
    // Table of contents
    // =========================================================================
    writeln!(f, "## Table of Contents\n").unwrap();
    for component in components {
        let anchor = component.name.to_lowercase();
        writeln!(f, "- [{}](#{})", component.name, anchor).unwrap();
    }
    writeln!(f, "\n---\n").unwrap();

    // =========================================================================
    // Component sections
    // =========================================================================
    for component in components {
        generate_component_doc(component, &mut f);
    }

    // =========================================================================
    // Footer with legend
    // =========================================================================
    writeln!(
        f,
        "
---

## Legend

### Type Abbreviations
- **`string`**: Text value, can include expressions `${{state.field}}`
- **`number`**: Numeric value (integer or float)
- **`boolean`**: `true` or `false`
- **`expression`**: JavaScript-like expression
- **`action[]`**: Array of action definitions

### Deprecation Markers
- ⚠️ **Deprecated**: This feature will be removed in a future version
- Hover or click for migration instructions

---

*Generated by Orbis Build System*
"
    )
    .unwrap();
}

// =============================================================================
// COMPONENT DOCUMENTATION HELPER
// =============================================================================

/// Generates documentation for a single component.
///
/// Outputs a Markdown section containing:
/// - Component name as heading
/// - Description text
/// - Attributes table with type info and deprecation status
/// - Events table with handler signatures and deprecation status
///
/// # Arguments
/// * `component` - The component definition to document
/// * `f` - File handle to write to
fn generate_component_doc(component: &ComponentDef, f: &mut File) {
    // =========================================================================
    // Component heading
    // =========================================================================
    writeln!(f, "## {}\n", component.name).unwrap();
    writeln!(f, "{}\n", component.description).unwrap();

    // =========================================================================
    // Attributes section
    // =========================================================================
    if !component.attributes.is_empty() {
        writeln!(f, "### Attributes\n").unwrap();
        writeln!(
            f,
            "| Attribute | Allowed Values | Deprecated |"
        )
        .unwrap();
        writeln!(f, "|-----------|----------------|------------|").unwrap();

        for attr in &component.attributes {
            generate_attribute_row(attr, f);
        }
        writeln!(f).unwrap();
    }

    // =========================================================================
    // Events section
    // =========================================================================
    if !component.events.is_empty() {
        writeln!(f, "### Events\n").unwrap();
        writeln!(f, "| Event | Description | Deprecated |").unwrap();
        writeln!(f, "|-------|-------------|------------|").unwrap();

        for event in &component.events {
            generate_event_row(event, f);
        }
        writeln!(f).unwrap();
    }

    // =========================================================================
    // Usage examples (if available)
    // =========================================================================
    generate_usage_example(component, f);

    writeln!(f, "---\n").unwrap();
}

/// Generates a table row for an attribute.
///
/// Format: `| name | allowed values | deprecated |`
fn generate_attribute_row(attr: &AttributeDef, f: &mut File) {
    // Format allowed values (or "-" if not constrained)
    let allowed_values = match &attr.allowed_values {
        Some(values) => {
            let formatted: Vec<String> = values.iter().map(|v| format!("`{}`", v)).collect();
            formatted.join(", ")
        }
        None => "-".to_string(),
    };

    // Format deprecation info
    let deprecated = match &attr.deprecated {
        Some(info) => {
            let alternative = info
                .alternative
                .as_ref()
                .map(|r| format!(" → use `{}`", r))
                .unwrap_or_default();
            format!("⚠️ {}{}", info.message, alternative)
        }
        None => "No".to_string(),
    };

    writeln!(
        f,
        "| `{}` | {} | {} |",
        attr.name, allowed_values, deprecated
    )
    .unwrap();
}

/// Generates a table row for an event.
///
/// Format: `| @event | description | deprecated |`
fn generate_event_row(event: &EventDef, f: &mut File) {
    let deprecated = match &event.deprecated {
        Some(info) => {
            let alternative = info
                .alternative
                .as_ref()
                .map(|r| format!(" → use `@{}`", r))
                .unwrap_or_default();
            format!("⚠️ {}{}", info.message, alternative)
        }
        None => "No".to_string(),
    };

    writeln!(f, "| `@{}` | {} | {} |", event.name, event.description, deprecated).unwrap();
}

/// Generates a usage example for a component.
///
/// Provides a minimal DSL snippet showing how to use the component.
fn generate_usage_example(component: &ComponentDef, f: &mut File) {
    writeln!(f, "### Example\n").unwrap();
    writeln!(f, "```orbis").unwrap();

    // Build example attributes - use first few attributes with their first allowed value
    let example_attrs: Vec<String> = component
        .attributes
        .iter()
        .take(3)
        .map(|a| {
            let value = match &a.allowed_values {
                Some(values) if !values.is_empty() => format!("\"{}\"", values[0]),
                _ => "\"example\"".to_string(),
            };
            format!("{}={}", a.name, value)
        })
        .collect();

    // Build example event
    let event_example = component.events.first().map(|e| {
        format!("@{}=>{{ toast.success(\"Clicked!\") }}", e.name)
    });

    // Determine if should be self-closing
    let is_container = component.name == "Container"
        || component.name == "Flex"
        || component.name == "Grid"
        || component.name == "Form"
        || component.name == "Card";

    let attrs_str = example_attrs.join(" ");
    let event_str = event_example.unwrap_or_default();
    
    if is_container {
        writeln!(
            f,
            "<{} {} {}>",
            component.name, attrs_str, event_str
        )
        .unwrap();
        writeln!(f, "  // Child components here").unwrap();
        writeln!(f, "</{}>", component.name).unwrap();
    } else {
        writeln!(
            f,
            "<{} {} {} />",
            component.name, attrs_str, event_str
        )
        .unwrap();
    }

    writeln!(f, "```\n").unwrap();
}

// =============================================================================
// SPECIALIZED DOCUMENTATION GENERATORS
// =============================================================================

/// Generates a quick-reference cheat sheet.
///
/// A compact single-page reference for common use cases.
pub fn generate_cheat_sheet(components: &[ComponentDef]) {
    let doc_path = std::path::Path::new("COMPONENTS_CHEATSHEET.md");
    let mut f = File::create(doc_path).expect("Failed to create cheat sheet");

    writeln!(
        f,
        "# Orbis DSL Cheat Sheet

> Quick reference for common patterns. See [COMPONENTS_REFERENCE.md](COMPONENTS_REFERENCE.md) for full details.

## Quick Component Reference

"
    )
    .unwrap();

    // Group by category
    let categories = [
        ("Layout", vec!["Container", "Grid", "Flex", "Spacer", "Divider"]),
        ("Typography", vec!["Text", "Heading"]),
        ("Forms", vec!["Form", "Field", "Button", "Dropdown"]),
        ("Data Display", vec!["Card", "Table", "List", "Badge", "StatCard"]),
        ("Feedback", vec!["Alert", "Progress", "LoadingOverlay"]),
        ("Navigation", vec!["Link", "Tabs", "Breadcrumb"]),
    ];

    for (category, component_names) in categories {
        writeln!(f, "### {}\n", category).unwrap();
        writeln!(f, "| Component | Key Attributes | Events |").unwrap();
        writeln!(f, "|-----------|----------------|--------|").unwrap();

        for name in component_names {
            if let Some(comp) = components.iter().find(|c| c.name == name) {
                let key_attrs: Vec<&str> = comp
                    .attributes
                    .iter()
                    .filter(|a| a.name == "variant" || a.name == "size" || a.name == "label" || a.name == "type")
                    .take(4)
                    .map(|a| a.name)
                    .collect();

                let events: Vec<String> = comp
                    .events
                    .iter()
                    .take(2)
                    .map(|e| format!("@{}", e.name))
                    .collect();

                writeln!(
                    f,
                    "| `{}` | {} | {} |",
                    name,
                    key_attrs.join(", "),
                    events.join(", ")
                )
                .unwrap();
            }
        }
        writeln!(f).unwrap();
    }

    writeln!(
        f,
        "
## Common Patterns

### Button with action
```orbis
<Button label=\"Save\" variant=\"default\" @click=>{{ api.saveData() }} />
```

### Form with validation
```orbis
<Form id=\"loginForm\" @submit=>{{ api.login(state.formData) }}>
  <Field name=\"email\" type=\"email\" required=true label=\"Email\" />
  <Field name=\"password\" type=\"password\" required=true label=\"Password\" />
  <Button type=\"submit\" label=\"Login\" />
</Form>
```

### Conditional rendering
```orbis
if state.isLoading {{
  <LoadingOverlay visible=true />
}} else {{
  <Container>
    <Text>Content loaded!</Text>
  </Container>
}}
```
"
    )
    .unwrap();
}
