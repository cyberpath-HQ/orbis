---
sidebar_position: 2
title: Quickstart
description: Build your first Orbis plugin in 5 minutes
---

import CodeBlock from '@/components/mdx/CodeBlock.astro';


# Quickstart

Build your first Orbis plugin in 5 minutes using the Orbis SDK. This tutorial walks you through creating a simple "Hello World" plugin with interactive UI and server-side logic.

## What You'll Build

A plugin that:
- Displays a greeting message with customizable name
- Has server-side state management
- Counts button clicks using API routes
- Shows dynamic UI updates

## Prerequisites

- Rust installed (1.70+)
- wasm32-unknown-unknown target: `rustup target add wasm32-unknown-unknown`
- Basic familiarity with Rust and JSON

## Step 1: Create the Project

<CodeBlock lang="bash">
```bash
# Create a new Rust library project
cargo new --lib hello-plugin
cd hello-plugin
```
</CodeBlock>

## Step 2: Configure Cargo.toml

<CodeBlock lang="toml">
```toml
[package]
name = "hello-plugin"
version = "1.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
orbis-plugin-api = { path = "../crates/orbis-plugin-api" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[profile.release]
opt-level = "s"        # Optimize for size
lto = true             # Link-time optimization
strip = true           # Strip symbols
codegen-units = 1      # Single codegen unit
panic = "abort"        # Abort on panic
```
</CodeBlock>

## Step 3: Write the Plugin Code

Create `src/lib.rs`:

<CodeBlock lang="rust">
```rust
use orbis_plugin_api::sdk::prelude::*;
use serde_json::json;

// Initialize the plugin with zero boilerplate
orbis_plugin!();

/// Get personalized greeting
fn get_greeting_impl(ctx: Context) -> Result<Response> {
    // Get name from query parameter or use "World"
    let name = ctx.query_param("name").unwrap_or("World");
    
    // Get click count from state
    let count: i32 = state::get("count")?.unwrap_or(0);
    
    log::info!("Greeting requested for: {}", name);
    
    Response::json(&json!({
        "message": format!("Hello, {}!", name),
        "clickCount": count
    }))
}

/// Increment click counter
fn increment_count_impl(_ctx: Context) -> Result<Response> {
    // Get current count
    let count: i32 = state::get("count")?.unwrap_or(0);
    let new_count = count + 1;
    
    // Save new count
    state::set("count", &new_count)?;
    
    log::info!("Count incremented to: {}", new_count);
    
    Response::json(&json!({
        "count": new_count,
        "message": format!("Clicked {} times!", new_count)
    }))
}

// Export handlers for FFI
wrap_handler!(get_greeting, get_greeting_impl);
wrap_handler!(increment_count, increment_count_impl);
```
</CodeBlock>

## Step 4: Create the Manifest

Create `manifest.json`:

<CodeBlock lang="json">
```json
{
  "name": "hello-plugin",
  "version": "1.0.0",
  "description": "A simple greeting plugin with click counter",
  "author": "You",
  "license": "MIT",
  "min_orbis_version": "1.0.0",
  
  "wasm_entry": "hello_plugin.wasm",
  
  "routes": [
    {
      "path": "/greeting",
      "method": "GET",
      "handler": "get_greeting"
    },
    {
      "path": "/increment",
      "method": "POST",
      "handler": "increment_count"
    }
  ],
  
  "pages": [
    {
      "id": "greeting-page",
      "title": "Hello",
      "icon": "wave",
      "route": "/hello",
      
      "state": {
        "name": {
          "type": "string",
          "default": "World"
        },
        "count": {
          "type": "number",
          "default": 0
        },
        "message": {
          "type": "string",
          "default": ""
        }
      },
      
      "layout": {
        "type": "Container",
        "className": "flex items-center justify-center min-h-screen bg-gradient-to-br from-purple-500 to-pink-500",
        "children": [
          {
            "type": "Card",
            "className": "p-8 shadow-2xl max-w-md w-full",
            "children": [
              {
                "type": "Text",
                "text": "Hello, ${state.name}!",
                "variant": "h1",
                "className": "text-4xl font-bold text-center mb-2"
              },
              {
                "type": "Text",
                "text": "Clicks: ${state.count}",
                "variant": "p",
                "className": "text-center text-gray-600 mb-6"
              },
              {
                "type": "Input",
                "fieldType": "text",
                "placeholder": "Enter your name",
                "value": "${state.name}",
                "className": "mb-4",
                "events": {
                  "onChange": [
                    {
                      "type": "updateState",
                      "path": "name",
                      "value": "${$event.target.value}"
                    }
                  ]
                }
              },
              {
                "type": "Button",
                "text": "Click Me!",
                "className": "w-full",
                "events": {
                  "onClick": [
                    {
                      "type": "callApi",
                      "api": "/increment",
                      "method": "POST",
                      "onSuccess": [
                        {
                          "type": "updateState",
                          "path": "count",
                          "value": "${$response.count}"
                        },
                        {
                          "type": "showToast",
                          "message": "${$response.message}",
                          "level": "success"
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    }
  ]
}
```
</CodeBlock>

## Step 5: Build the Plugin

<CodeBlock lang="bash">
```bash
# Build WASM binary
cargo build --target wasm32-unknown-unknown --release

# Output will be at:
# target/wasm32-unknown-unknown/release/hello_plugin.wasm
```
</CodeBlock>

**Build optimization:** The `[profile.release]` settings reduce binary size from ~2MB to ~200KB.

## Step 6: Install the Plugin

<CodeBlock lang="bash">
```bash
# Create plugin directory
mkdir -p ~/.orbis/plugins/hello-plugin

# Copy WASM binary and manifest
cp target/wasm32-unknown-unknown/release/hello_plugin.wasm ~/.orbis/plugins/hello-plugin/
cp manifest.json ~/.orbis/plugins/hello-plugin/

# Or use custom plugin directory
export ORBIS_PLUGINS_DIR=/path/to/plugins
cp target/wasm32-unknown-unknown/release/hello_plugin.wasm $ORBIS_PLUGINS_DIR/hello-plugin/
cp manifest.json $ORBIS_PLUGINS_DIR/hello-plugin/
```
</CodeBlock>

## Step 7: Run Orbis

<CodeBlock lang="bash">
```bash
# From the orbis project root
cd orbis
bun run tauri dev
```
</CodeBlock>

Navigate to the "Hello" page in the sidebar. You should see:
- A greeting with your custom name
- An input to change the name
- A button that increments the counter
- Toast notifications on each click

## Understanding the Code

### Zero-Boilerplate Initialization

The `orbis_plugin!()` macro handles all FFI setup:
<CodeBlock lang="rust">
```rust
orbis_plugin!();  // Expands to:
// - init() function
// - allocate/deallocate memory management
// - execute() dispatcher
// - All extern declarations for host functions
```
</CodeBlock>

### Type-Safe Handler Wrapping

The `#[wrap_handler]` attribute eliminates manual FFI:
<CodeBlock lang="rust">
```rust
#[wrap_handler]
pub fn get_greeting(ctx: Context) -> Result<Response> {
    // Your business logic here
}

// Expands to FFI-compatible export with:
// - Request parsing from memory
// - Error handling
// - Response serialization
```
</CodeBlock>

### Context API

The `Context` provides request data:
<CodeBlock lang="rust">
```rust
ctx.query_param("name")         // Get query parameter
ctx.query_param_as::<i32>("id") // Parse as type
ctx.body_as::<MyStruct>()       // Deserialize body
```
</CodeBlock>

### Response Builders

Convenient response creation:
<CodeBlock lang="rust">
```rust
Response::json(&data)                    // JSON response
Response::text("Hello")                  // Plain text
Response::new(200, "OK", json!({}))     // Custom response
```
</CodeBlock>

### State Management

Type-safe persistent state:
<CodeBlock lang="rust">
```rust
state::get::<i32>("count")      // Get typed value
state::set("count", 42)         // Set value
state::delete("count")          // Remove value
```
</CodeBlock>

## Next Steps

Now that you've built your first plugin, explore:

### Plugin Development
- **[WASM Plugins](../plugin-development/wasm-plugins)** - Full SDK reference with advanced examples
- **[Building Plugins](../plugin-development/building-plugins)** - Build optimization and packaging
- **[Testing Plugins](../plugin-development/testing-plugins)** - Testing strategies

### SDK Features
- **[Database Access](../plugin-development/wasm-plugins#database-access)** - Query and execute SQL
- **[HTTP Requests](../plugin-development/wasm-plugins#http-requests)** - Make external API calls
- **[Logging](../plugin-development/wasm-plugins#logging)** - Debug and monitoring
- **[Permissions](../plugin-development/wasm-plugins#permissions)** - Security and access control

### UI Development
- **[Schema System](../core-concepts/schema-system)** - Deep dive into UI schemas
- **[Components](../components/overview)** - All available components
- **[Actions](../actions/overview)** - All action types
- **[State & Expressions](../core-concepts/state-management)** - Dynamic UI patterns

## Complete Example

For a production-ready example with database access and HTTP requests, see the [TODO Plugin](https://github.com/cyberpath-HQ/orbis/tree/main/plugins/todo-plugin) in the repository.
