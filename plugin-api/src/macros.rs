/// Creates the `create_plugin` function for the specified plugin type.
#[macro_export]
macro_rules! create_plugin {
    ($plugin_type:ty) => {
        #[unsafe(no_mangle)]
        pub extern "C" fn create_plugin() -> *mut dyn $crate::Plugin {
            let plugin = <$plugin_type>::new();
            Box::into_raw(Box::new(plugin))
        }
    };
}

/// Loads the PluginContext from the plugin's context_ptr
#[macro_export]
macro_rules! load_context {
    ($plugin_name:ident) => {
        {
            let context_ptr = $plugin_name.context_ptr.load(std::sync::atomic::Ordering::SeqCst);
            let context = unsafe { context_ptr.as_mut() };
            let context = context.ok_or(
                $crate::PluginError::InitializationError("Cannot get PluginContext from pointer".to_owned())
            )?;
            context
        }
    };
}

/// Macro to create a plugin with specified properties and methods
///
/// # Arguments
/// * `plugin_name` - Identifier for the plugin struct
/// * `name` - Plugin name as a string
/// * `version` - Plugin version as a string
/// * `author` - Plugin author as a string
/// * `init` - Initialization function body
/// * `shutdown` - Shutdown function body
/// * `register_hooks` - Hook registration function body
///  # Example
/// ```rust no_run
/// make_plugin!({
///     plugin_name: Example,
///     name:    "example_plugin",
///     version: "0.1.0",
///     author:  "Emanuele (Ebalo) Balsamo",
///     init(&mut self, context: &mut PluginContext) -> Result<(), plugin_api::PluginError> {
///         // do initialization here
///         Ok(())
///     }
///     shutdown(&mut self) -> Result<(), plugin_api::PluginError> {
///         // do shutdown here
///         Ok(())
///     }
///     register_hooks(&self, hook_registry: *mut ()) -> Result<(), plugin_api::PluginError> {
///         // register hooks here
///         Ok(())
///     }
/// });
/// ```
#[macro_export]
macro_rules! make_plugin {
    ({
        plugin_name: $plugin_name:ident,
        name: $name:expr,
        version: $version:expr,
        author: $author:expr,
        init(&mut $self_init:ident, $context:ident: &mut PluginContext) -> Result<(), $init_err:ty> {
            $($init_body:tt)*
        }
        shutdown(&mut $self_shutdown:ident) -> Result<(), $shutdown_err:ty> {
            $($shutdown_body:tt)*
        }
        register_hooks(&$self_hooks:ident, $hook_registry:ident: *mut ()) -> Result<(), $hooks_err:ty> {
            $($register_hooks_body:tt)*
        }
    }) => {
        $crate::paste::paste! {
            /// Plugin structure generated by make_plugin! macro
            pub struct [<$plugin_name Plugin>] {
                name:        String,
                version:     String,
                author:      String,
                pub context_ptr: std::sync::atomic::AtomicPtr<$crate::PluginContext>,
            }

            impl [<$plugin_name Plugin>] {
                pub fn new() -> Self {
                    Self {
                        name:        $name.to_string(),
                        version:     $version.to_string(),
                        author:      $author.to_string(),
                        context_ptr: std::sync::atomic::AtomicPtr::new(std::ptr::null_mut()),
                    }
                }
            }

            impl Default for [<$plugin_name Plugin>] {
                fn default() -> Self {
                    Self::new()
                }
            }

            #[$crate::async_trait::async_trait(?Send)]
            impl $crate::Plugin for [<$plugin_name Plugin>] {
                /// Gets the plugin name
                fn name(&self) -> &str {
                    &self.name
                }

                /// Gets the plugin version
                fn version(&self) -> &str {
                    &self.version
                }

                /// Gets the plugin author
                fn author(&self) -> &str {
                    &self.author
                }

                /// Initializes the plugin with the provided context
                /// # Arguments
                /// * `context` - Pointer to the PluginContext
                /// # Errors
                /// Returns an error if initialization fails
                async fn init(&mut $self_init, $context: *const ()) -> Result<(), $crate::PluginError> {
                    use std::sync::atomic::Ordering;

                    tracing::info!(
                        "[{}] Initializing plugin v{} by {}",
                        $self_init.name, $self_init.version, $self_init.author
                    );

                    $self_init.context_ptr
                        .store($context as *mut $crate::PluginContext, Ordering::SeqCst);

                    let $context = $crate::load_context!($self_init);

                    // User-provided init body
                    let result = { $($init_body)* };

                    if result.is_ok() {
                        tracing::info!("[{}] Plugin initialized successfully!", $self_init.name);
                    } else {
                        tracing::error!("[{}] Plugin initialization failed: {}", $self_init.name, result.as_ref().err().unwrap());
                    }
                    result
                }

                async fn shutdown(&mut $self_shutdown) -> Result<(), $crate::PluginError> {
                    tracing::info!("[{}] Shutting down plugin", $self_shutdown.name);

                    let result = { $($shutdown_body)* };

                    if result.is_ok() {
                        tracing::info!("[{}] Plugin shut down!", $self_shutdown.name);
                    } else {
                        tracing::error!("[{}] Plugin shutdown failed: {}", $self_shutdown.name, result.as_ref().err().unwrap());
                    }
                    result
                }

                async fn register_hooks(&$self_hooks, $hook_registry: *mut ()) -> Result<(), $crate::PluginError> {
                    tracing::info!("[{}] Registering hooks", $self_hooks.name);

                    let result = { $($register_hooks_body)* };

                    if result.is_ok() {
                        tracing::info!("[{}] Hooks registered successfully!", $self_hooks.name);
                    } else {
                        tracing::error!("[{}] Hook registration failed: {}", $self_hooks.name, result.as_ref().err().unwrap());
                    }
                    result
                }
            }

            $crate::create_plugin!([<$plugin_name Plugin>]);
        }
    };
}